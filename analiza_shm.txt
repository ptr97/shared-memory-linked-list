Zakładając najprostszą wersję (stały rozmiar shm, przy powiększaniu chyba trzebaby kopiować starą pamięć i alokować większą)
widziałbym to tak:

Z tego co rozumiem celem tego zadania jest to aby utworzyć linked liste w shm, z której może korzystać kilka procesów.

Procesy te miały by wspólną definicję struktury, która jest zapisywana, np.

struct Example {
    int x;
};

korzystało by się z niej mniej więcej tak:
LinkedList<Example> ex("klucz", 4096*2 /*wielkość shm */) // Klucz żeby w drugim procesie można się było podłączyć; 
shm jest zaookrąglane do wielkości 1 strony (4096 bajtów)

a w drugim procesie:
LinkedList<Example> ex("klucz");


struct Node {
    struct Example value;
    uint next_offset; // Offset do następnego node'a od początku pamięci, -1 to jest null
};

Na początku pamięci byłby metadane do opisu struktury:

struct Meta {
    uint head_offset; // Offset do pierwszego node'a lub -1 jeśli lista jest pusta
};

Opcja 1: od razu podzielić całą pamięc na nody i oznaczyć czy dany node jest zapisany czy nie 
    + proste
    + szybkie usuwanie 0(1)
    - dodatkowe zużycie pamięci
    - dodawanie wymaga przechodzenia od począku pamięci po każdym nodzie aż znajdzie się wolne miejsce

Opcja 2: trzymać w Metadanych dodatkowy offset na usunięte nody (linked lista usuniętych), przy dodawaniu nowego 
node'a brało by się miejsce z tej listy albo na koniec jeśli lista usuniętych jest pusta, 
przy usuwaniu by się dodawało do tej listy
    - trudniejsze
    - dodatkowe zużycie pamięci (ale mniejsze niż przy Op.1)
    + szybkie dodawanie O(1)

Potrzebna jest synchronizacja dostępu do struktury - najprościej by było zrobić dostęp wyłączny jednym semaforem,
albo ładniej (https://pl.wikipedia.org/wiki/Problem_czytelników_i_pisarzy).

Pobranie node to by bylo chyba:
void *shm = ...
struct Example *head = shm + sizeof(Meta) + meta.head_offset * sizeof(Example); // pierwszy
